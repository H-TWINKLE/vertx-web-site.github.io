import Microservices from "@/assets/introduction/microservices.svg?react"
import MicroservicesDark from "@/assets/introduction/microservices-dark.svg?react"
import Threads from "@/assets/introduction/threads.svg?react"
import ThreadsDark from "@/assets/introduction/threads-dark.svg?react"
import BlockingIO from "@/assets/introduction/blocking-io.svg?react"
import BlockingIODark from "@/assets/introduction/blocking-io-dark.svg?react"
import EventLoop from "@/assets/introduction/event-loop.svg?react"
import EventLoopDark from "@/assets/introduction/event-loop-dark.svg?react"
import Async from "@/assets/introduction/async.svg?react"
import AsyncDark from "@/assets/introduction/async-dark.svg?react"
import Failures from "@/assets/introduction/failures.svg?react"
import FailuresDark from "@/assets/introduction/failures-dark.svg?react"
import Ecosystem from "@/assets/introduction/ecosystem.svg?react"
import EcosystemDark from "@/assets/introduction/ecosystem-dark.svg?react"

# Eclipse Vert.x and reactive in just a few words

Eclipse Vert.x is a tool-kit for building **reactive** applications on the JVM.
Reactive applications are both **scalable** as workloads grow, and **resilient** when failures arise.
A reactive application is **responsive** as it keeps latency under control by making efficient usage of system resources, and by protecting itself from errors.

<Microservices className="mx-auto max-w-full dark:hidden"/>
<MicroservicesDark className="mx-auto max-w-full hidden dark:block"/>

Vert.x is backed by a large ecosystem of reactive modules with just anything you need when writing modern services: a comprehensive web stack, reactive database drivers, messaging, event streams, clustering, metrics, distributed tracing and more.

Vert.x is a tool-kit and not a framework that ships with black magic: **what you write is actually what you get to execute**, as simple as that.

So what makes Vert.x a great option for writing your next **cloud-native** or [**twelve-factor**](https://12factor.net/) app?

<h2 id="in-the-beginning-there-were-threads">In the beginning, there were threads...</h2>

The classic approach to concurrency is to use **threads**.
Multiple threads can live within a single **process**, perform **concurrent** work, and **share** the same memory space.

<Threads className="mx-auto max-w-[30rem] dark:hidden"/>
<ThreadsDark className="mx-auto max-w-[30rem] hidden dark:block"/>

Most application and service development frameworks are based on multi-threading.
On the surface, the model of having **1 thread per connection** is reassuring because developers can rely on traditional **imperative style** code.

This is fine, especially if you forget about those silly mistakes you can make with multi-threading and memory access ...

<h2 id="multi-threading-is-simple-but-limited">Multi-threading is "simple" but limited</h2>

What happens as the workload grows beyond moderate workloads?
[(see the C10k problem)](https://en.wikipedia.org/wiki/C10k_problem)

The answer is simple: you start making your operating system kernel **suffer** because there is too much **context switching** work with in-flight requests.

<BlockingIO className="mx-auto max-w-[42rem] dark:hidden"/>
<BlockingIODark className="mx-auto max-w-[42rem] hidden dark:block"/>

Some of your threads will be **blocked** because they are waiting on I/O operations to complete, some will be **ready** to handle I/O results, and some will be in the middle of doing CPU-intensive tasks.

Modern kernels have very good schedulers, but you cannot expect them to deal with 50&thinsp;000 threads as easily as they would do with 5&thinsp;000. Also, threads aren't cheap: creating a thread takes a few milliseconds, and a new thread eats about 1MB of memory.

<h2 id="asynchronous-programming-scalability-and-resource-efficiency">Asynchronous programming: scalability and resource efficiency</h2>

Processing more concurrent connections with less threads is possible when you use **asynchronous I/O**.
Instead of blocking a thread when an I/O operation occurs, we move on to another task which is ready to progress, and resume the initial task later when it is ready.

Vert.x multiplexes concurrent workloads using **event loops**.

<EventLoop className="mx-auto max-w-full dark:hidden"/>
<EventLoopDark className="mx-auto max-w-full hidden dark:block"/>

Code that runs on event loops should not perform blocking I/O or lengthy processing. But don't worry if you have such code: Vert.x has worker threads and APIs to process events back on an event loop.

<h2 id="pick-the-best-asynchronous-programming-model-for-your-problem-domain">Pick the best asynchronous programming model for your problem domain</h2>

We know that asynchronous programming requires more efforts.
At the core of Vert.x, we support **callbacks** and **promises/futures**, the latter being a simple and elegant model for chaining asynchronous operations.

Advanced reactive programming is possible with [RxJava](https://github.com/ReactiveX/RxJava), and if you prefer something closer to traditional imperative programming, then we are happy to provide you with first-class support of [Kotlin coroutines](https://kotlinlang.org/docs/reference/coroutines-overview.html).

<Async className="mx-auto max-w-full dark:hidden"/>
<AsyncDark className="mx-auto max-w-full hidden dark:block"/>

Vert.x supports many asynchronous programming models: choose what works best for each problem you need to solve!

<h2 id="dont-let-failures-ruin-responsiveness">Don't let failures ruin responsiveness</h2>

Failures happen all the time.
A database will go down, the network will go down, or some service you depend on will become unresponsive.

<Failures className="mx-auto max-w-full dark:hidden"/>
<FailuresDark className="mx-auto max-w-full hidden dark:block"/>

Vert.x offers tools to keep latency under control, including a simple and efficient **circuit breaker**.

<h2 id="a-rich-ecosystem">A rich ecosystem</h2>

The _Eclipse Vert.x stack_ contains modules for building modern, end-to-end reactive services.
From efficient reactive database clients to event streaming, messaging and web stacks, the Eclipse Vert.x project has you covered:

<Ecosystem className="mx-auto max-w-full dark:hidden"/>
<EcosystemDark className="mx-auto max-w-full hidden dark:block"/>

Can't find what you are looking for?

* [The Reactiverse](https://reactiverse.io) is a larger community around the reactive ecosystems where you can find more client and modules.
* The [Vert.x Awesome](https://github.com/vert-x3/vertx-awesome) repository provides links to even more interesting projects from the larger open-source community!
